<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Platformer with Autotile Grass</title>
<style>
html,body {margin:0;padding:0;overflow:hidden;background:#000;}
canvas {display:block;image-rendering:pixelated;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);}
</style>
</head>
<body>
<canvas id="game" width=1440 height=810></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const TILE = 48, GRAV = 1800, MAX_FALL = 1000, COYOTE_TIME = 0.15, CAMERA_LERP = 0.08, CAMERA_SCALE = 1;

let levelFinished = false;

const rawBackground = [
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000111000000000000000000000000000000000000000',
'00000000001111000001111100000000000000000000000000000',
'00000000001111000001111100000000000000000000000000000',
'00000000000111000011111100000000000000000000000000000',
'00000000000000000011111100000000000000000111110000000',
'00000000000000000011111100000000000000000111110000000',
'00000000000000000000000000000000011000000111110000000',
'00000000000000000011111000000000011110000111110000000',
'00000000000000000011111000000000001110000111110000000',
'00000000000000000001111000000000000010000111110000000',
'00000000000000000001111000000000000000000000000000000',
'00000000000000000001111000000000000000000000000000000',
'00000000000000000001111000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
'00000000000000000000000000000000000000000000000000000',
];


let background = [];
rawBackground.forEach((row, y) => {
  let newRow = [];
  for (let x = 0; x < row.length; x++) {
    let c = row[x];
    if (c==='1'){ 
      newRow.push(1); 
    }
    else if (c==='d'){ 
      newRow.push(2); 
    }
    else newRow.push(0);
  }
  background.push(newRow);
});


const rawLevel = [
'11110000000000000000000000000000000000000000000000000',
'11110000000000000000000000000000000000000000000000000',
'11110000000000000000000000000000000000000000000000000',
'11110000000000000000000000000000000000000000000000000',
'11110000000000000000000000000000000000000000000000000',
'11110000000000000000000000000000000000000000000000000',
'11110000000000000000000000000000000000000000000000000',
'1111000000000000000000C000000000000000000000000000000',
'11110000000333330000000000000000000000000000000000000',
'111100001000000000033333000000000000000000000000000C0',
'111100001100C0000002223300000000000000000000000000000',
'11110000111000000002220000000000C00000111111111111111',
'11110000111111100002220000000000000001111111111111111',
'11110000000000000002220000001000000001111131311111111',
'11110000000000000111111100000000011111111111111111111',
'11110000000000000111111100000000000111111133311111111',
'11110000000000000000000100000000000001111113111111111',
'11110000022222200000000100000000000001111111111111111',
'11110000022222200003000122200000000001111111111111111',
'111100000222222000330C0122200000000001111111111111111',
'11110000022222200033000122200000000001111111111111111',
'1111111111111111111111111111111F001111111111111111111',
'11111111111111111111111111111111111111111111111111111',
'11111111111111111111111111111111111111111111111111111',
'11111111111111111111111111111111111111111111111111111',
];

let level = [], collectables = [], finish = null;
rawLevel.forEach((row, y) => {
  let newRow = [];
  for (let x = 0; x < row.length; x++) {
    let c = row[x];
    if (c==='1'){ 
      newRow.push(1); 
    }
    else if (c==='2'){ 
      newRow.push(2); 
    }
    else if (c==='3'){ 
      newRow.push(3); 
    }
    else if(c==='0'){ 
      newRow.push(0); 
    }
    else if(c==='C'){
      newRow.push(0);
      const img = new Image();
      img.src = "https://i.imgur.com/4MiY0Gd.png"; //collectable spr
      collectables.push({
        x: x * TILE,
        y: y * TILE,
        w: 32,
        h: 32,
        collected: false,
        img: img,
        frame: 0,
        frameCount: 4,
        frameSpeed: 0.3,
        timer: 0
      });
    }
    else if(c==='F'){ 
      newRow.push(0);
      finish = {x: x*TILE, y: y*TILE, w: TILE*3, h: TILE};
    }
    else newRow.push(0);
  }
  level.push(newRow);
});


const MAP_W = level[0].length;
const MAP_H = level.length;
const WORLD_W = MAP_W*TILE;
const WORLD_H = MAP_H*TILE;

// --- Camera ---
const camera = {x:0,y:0,w:canvas.width,h:canvas.height, tx:0, ty:0};

// --- Player ---
const player = {x:TILE*5+6,y:WORLD_H-TILE*7,w:34,h:44,vx:0,vy:0,speed:520,jumpPower:620,onGround:false,jumpsLeft:2,coyoteTimer:0};
const playerImg = new Image();
playerImg.src = "https://i.imgur.com/bErc7cJ.png"; // player spr
player.frame = 0;
player.frameTimer = 0;
player.frameSpeed = 0.12;
player.state = "idle";


// --- Inputs ---
const keys = {left:false,right:false,jump:false};
window.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft'||e.key==='a') keys.left=true;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
  if(e.code==='Space') keys.jump=true;
});
window.addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft'||e.key==='a') keys.left=false;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
  if(e.code==='Space') keys.jump=false;
});

// --- Tiles drawing ---
const tileImages = {
  1: new Image(),
  2: new Image(),
  3: new Image()
};
tileImages[1].src="https://i.imgur.com/MuKldpK.png"; //planks spr
tileImages[2].src="https://i.imgur.com/nOVCQCo.png"; //shelf spr
tileImages[3].src="https://i.imgur.com/v5B1tpw.png"; //lego
const finishImg = new Image();
finishImg.src = "https://i.imgur.com/62Pml8N.png"; //finish spr

const bgTileImages = {
  1: new Image()
};
bgTileImages[1].src = "https://i.imgur.com/K6bmxLJ.png"; //wallpaper spr


// --- Autotile helper ---
function getAutotileSrc(tileX, tileY){ return {sx: tileX*128, sy: tileY*128, w:128, h:128}; }

// --- Collision ---
function resolveCollisions(dt) {
  // Horizontal
  player.x += player.vx * dt;
  if(player.x < 0) player.x = 0;
  if(player.x + player.w > WORLD_W) player.x = WORLD_W - player.w;

  let left = player.x, right = player.x + player.w, top = player.y, bottom = player.y + player.h;
  let minTy = Math.floor(top/TILE), maxTy = Math.floor((bottom-1)/TILE);

  if(player.vx>0){
    const tx = Math.floor(right/TILE);
    for(let ty=minTy; ty<=maxTy; ty++){
      const tile = level[ty][tx];
      if(tile === 1 || tile === 3 || (finish && !allCollected() && tx*TILE < finish.x+finish.w && tx*TILE+TILE > finish.x && ty*TILE < finish.y+finish.h && ty*TILE+TILE > finish.y)){
        player.x = tx*TILE - player.w - 0.01; player.vx=0; break;
      }
    }
  } else if(player.vx<0){
    const tx = Math.floor(left/TILE);
    for(let ty=minTy; ty<=maxTy; ty++){
      const tile = level[ty][tx];
      if(tile === 1 || tile === 3 || (finish && !allCollected() && tx*TILE < finish.x+finish.w && tx*TILE+TILE > finish.x && ty*TILE < finish.y+finish.h && ty*TILE+TILE > finish.y)){
        player.x = (tx+1)*TILE + 0.01; player.vx=0; break;
      }
    }
  }





  // Vertical
  player.y += player.vy*dt;
  top = player.y; bottom = player.y+player.h; left = player.x; right = player.x+player.w;
  minTy = Math.floor(top/TILE); maxTy = Math.floor((bottom-1)/TILE);
  let minTx = Math.floor(left/TILE), maxTx = Math.floor((right-1)/TILE);

  // Falling
  if (player.vy > 0) {
    const ty = Math.floor(bottom / TILE);
    for (let tx = minTx; tx <= maxTx; tx++) {
      const tile = level[ty][tx];

      const tileIsSolid = tile === 1 || tile === 3;
      const tileIsSemi = tile === 2 && ((ty - 1 < 0) || level[ty - 1][tx] !== 2) && player.y + player.h <= ty * TILE + 12;


      const onFinish = finish &&
        player.x + player.w > finish.x &&
        player.x < finish.x + finish.w &&
        player.y + player.h > finish.y &&
        player.y + player.h < finish.y + finish.h;


      if (tileIsSolid || tileIsSemi || onFinish && collectables.filter(c=>!c.collected).length !== 0) {
        player.y = ty * TILE - player.h - 0.01;
        player.vy = 0;
        player.onGround = true;
        player.coyoteTimer = COYOTE_TIME;
        player.jumpsLeft = 2;
        break;
      }
    }
  }

  // Rising
  if(player.vy < 0){
    const ty = Math.floor(top / TILE);
    for(let tx = minTx; tx <= maxTx; tx++){
      const tile = level[ty][tx];
      if(tile === 1 || tile === 3){
        player.y = (ty + 1) * TILE + 0.01;
        player.vy = 0;
        break;
      }
    }
  }


    if(!player.onGround) player.coyoteTimer -= dt;
    player.onGround=false;
  }


// --- Collect count ---
function allCollected(){
  return collectables.every(c => c.collected);
}


// --- Camera ---
function updateCamera(dt) {
  camera.tx = Math.floor(player.x + player.w / 2 - camera.w / 2);
  camera.ty = Math.floor(player.y + player.h / 2 - camera.h / 2);

  camera.tx = Math.max(0, Math.min(camera.tx, WORLD_W - camera.w));
  camera.ty = Math.max(0, Math.min(camera.ty, WORLD_H - camera.h));

  camera.x += (camera.tx - camera.x) * CAMERA_LERP;
  camera.y += (camera.ty - camera.y) * CAMERA_LERP;

  camera.x = Math.round(camera.x);
  camera.y = Math.round(camera.y);
}


// --- Background ---
const bgImage = new Image();
bgImage.src = "https://i.imgur.com/kcaDRoO.png"; //background spr
const BG_SPEED = 0.5;

// --- Render ---
function render(){
  const camX = camera.x, camY = camera.y;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(bgImage.complete){
    ctx.fillStyle="#87CEEB"; //color
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const bgWidth = 1024;
    const bgHeight = bgImage.height;
    const startX = Math.round(-((camX * BG_SPEED) % bgWidth));
    for(let x = startX - bgWidth; x < canvas.width; x += bgWidth){
      ctx.drawImage(bgImage, x, 0, bgWidth, canvas.height);
    }

  } else {
    ctx.fillStyle="#87CEEB"; //fail color
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }


function isNeighborForTile(tileValue, currentTile) {
    if (currentTile === 1 && tileValue === 1) return true;
    if (currentTile === 1 && tileValue === 1) return true;
    return tileValue === currentTile;
}



  // --- Tiles ---
  const startCol = Math.floor(camX/TILE), endCol = Math.floor((camX+camera.w)/TILE);
  const startRow = Math.floor(camY/TILE), endRow = Math.floor((camY+camera.h)/TILE);


  // --- Background Tiles ---
  for (let y = startRow; y <= endRow; y++) {
    for (let x = startCol; x <= endCol; x++) {
      if (x < 0 || y < 0 || x >= MAP_W || y >= MAP_H) continue;

      const t = background[y]?.[x] ?? 0;
      if (t === 0) continue;

      function isNeighborForBackground(tileValue) {
          if(tileValue === 1) return true;
          return tileValue !== 0;
      }


      let up    = (y-1 < 0 || isNeighborForBackground(background[y-1]?.[x] || level[y-1]?.[x])) ? 1 : 0;
      let down  = (y+1 >= MAP_H || isNeighborForBackground(background[y+1]?.[x] || level[y+1]?.[x])) ? 1 : 0;
      let left  = (x-1 < 0 || isNeighborForBackground(background[y]?.[x-1] || level[y]?.[x-1])) ? 1 : 0;
      let right = (x+1 >= MAP_W || isNeighborForBackground(background[y]?.[x+1] || level[y]?.[x+1])) ? 1 : 0;

      // diagonals
      let left_up    = (y-1<0 || x-1<0 || isNeighborForBackground(background[y-1]?.[x-1] || level[y-1]?.[x-1])) ? 1 : 0;
      let right_up   = (y-1<0 || x+1>=MAP_W || isNeighborForBackground(background[y-1]?.[x+1] || level[y-1]?.[x+1])) ? 1 : 0;
      let left_down  = (y+1>=MAP_H || x-1<0 || isNeighborForBackground(background[y+1]?.[x-1] || level[y+1]?.[x-1])) ? 1 : 0;
      let right_down = (y+1>=MAP_H || x+1>=MAP_W || isNeighborForBackground(background[y+1]?.[x+1] || level[y+1]?.[x+1])) ? 1 : 0;



      let mask = up * 1 + down * 2 + left * 4 + right * 8;
      if (up && left) mask += left_up * 16;
      if (up && right) mask += right_up * 32;
      if (down && left) mask += left_down * 64;
      if (down && right) mask += right_down * 128;

      // --- Tile map ---
      const BackgroundRawTileMap = {
        "10": { x: 0, y: 0 }, "14": { x: 1, y: 0 }, "6": { x: 2, y: 0 }, "2": { x: 3, y: 0 },
        31: { x: 4, y: 0 }, 142: { x: 5, y: 0 }, 78: { x: 6, y: 0 }, 47: { x: 7, y: 0 },
        138: { x: 8, y: 0 }, 207: { x: 9, y: 0 }, 206: { x: 10, y: 0 }, 70: { x: 11, y: 0 },
        "11": { x: 0, y: 1 }, "15": { x: 1, y: 1 }, "7": { x: 2, y: 1 }, "3": { x: 3, y: 1 },
        139: { x: 4, y: 1 }, 239: { x: 5, y: 1 }, 223: { x: 6, y: 1 }, 71: { x: 7, y: 1 },
        171: { x: 8, y: 1 }, 111: { x: 9, y: 1 }, 95: { x: 11, y: 1 },
        "9": { x: 0, y: 2 }, "13": { x: 1, y: 2 }, "5": { x: 2, y: 2 }, "1": { x: 3, y: 2 },
        43: { x: 4, y: 2 }, 191: { x: 5, y: 2 }, 127: { x: 6, y: 2 }, 23: { x: 7, y: 2 },
        175: { x: 8, y: 2 }, 255: { x: 9, y: 2 }, 159: { x: 10, y: 2 }, 87: { x: 11, y: 2 },
        "8": { x: 0, y: 3 }, "12": { x: 1, y: 3 }, "4": { x: 2, y: 3 }, "0": { x: 3, y: 3 },
        79: { x: 4, y: 3 }, 45: { x: 5, y: 3 }, 29: { x: 6, y: 3 }, 143: { x: 7, y: 3 },
        41: { x: 8, y: 3 }, 61: { x: 9, y: 3 }, 63: { x: 10, y: 3 }, 21: { x: 11, y: 3 }
      };

      const BackgroundTileMap = {};
      for (const key in BackgroundRawTileMap) {
        const ids = key.split('/').map(k => parseInt(k));
        for (const id of ids) BackgroundTileMap[id] = BackgroundRawTileMap[key];
      }

      const src = BackgroundTileMap[mask] || { x: 3, y: 3 };
      const rect = getAutotileSrc(src.x, src.y);

      ctx.drawImage(
        bgTileImages[t],
        rect.sx + 8, rect.sy + 8, rect.w, rect.h,
        x * TILE - camX, y * TILE - camY,
        TILE, TILE
      );
    }
  }






  for(let y=startRow;y<=endRow;y++){
    for(let x=startCol;x<=endCol;x++){
      if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue;
      const t = level[y][x]; if(t===0) continue;

      if(t===1){
          let up = (y-1 < 0 || isNeighborForTile(level[y-1]?.[x], t)) ? 1 : 0;
          let down = (y+1 >= MAP_H || isNeighborForTile(level[y+1]?.[x], t)) ? 1 : 0;
          let left = (x-1 < 0 || isNeighborForTile(level[y]?.[x-1], t)) ? 1 : 0;
          let right = (x+1 >= MAP_W || isNeighborForTile(level[y]?.[x+1], t)) ? 1 : 0;

          let left_up = (y-1<0 || x-1<0 || isNeighborForTile(level[y-1]?.[x-1], t)) ? 1 : 0;
          let right_up = (y-1<0 || x+1>=MAP_W || isNeighborForTile(level[y-1]?.[x+1], t)) ? 1 : 0;
          let left_down = (y+1>=MAP_H || x-1<0 || isNeighborForTile(level[y+1]?.[x-1], t)) ? 1 : 0;
          let right_down = (y+1>=MAP_H || x+1>=MAP_W || isNeighborForTile(level[y+1]?.[x+1], t)) ? 1 : 0;


          let mask = up * 1 + down * 2 + left * 4 + right * 8;
          
          if (up && left) mask += left_up * 16;
          if (up && right) mask += right_up * 32;
          if (down && left) mask += left_down * 64;
          if (down && right) mask += right_down * 128;


          const rawTileMap = {
              "10":{x:0,y:0},"14":{x:1,y:0},"6":{x:2,y:0},"2":{x:3,y:0},  31:{x:4,y:0}, 142:{x:5,y:0},78:{x:6,y:0}, 47:{x:7,y:0}  , 138:{x:8,y:0},207:{x:9,y:0},206:{x:10,y:0},70:{x:11,y:0},
              "11":{x:0,y:1},"15":{x:1,y:1},"7":{x:2,y:1},"3":{x:3,y:1},  139:{x:4,y:1},239:{x:5,y:1},223:{x:6,y:1},71:{x:7,y:1}  , 171:{x:8,y:1},111:{x:9,y:1},               95:{x:11,y:1},
              "9":{x:0,y:2}, "13":{x:1,y:2},"5":{x:2,y:2},"1":{x:3,y:2},  43:{x:4,y:2}, 191:{x:5,y:2},127:{x:6,y:2},23:{x:7,y:2}  , 175:{x:8,y:2},255:{x:9,y:2},159:{x:10,y:2},87:{x:11,y:2},
              "8":{x:0,y:3}, "12":{x:1,y:3},"4":{x:2,y:3},"0":{x:3,y:3},  79:{x:4,y:3}, 45:{x:5,y:3}, 29:{x:6,y:3}, 143:{x:7,y:3}  ,41:{x:8,y:3}, 61:{x:9,y:3}, 63:{x:10,y:3}, 21:{x:11,y:3},
          };
        const tileMap = {};
        for (const key in rawTileMap) {
          const ids = key.split('/').map(k => parseInt(k));
          for (const id of ids) tileMap[id] = rawTileMap[key];
        }

        // --- Draw the correct autotile ---
        let src = tileMap[mask] || {x:3, y:3};
        let rect = getAutotileSrc(src.x, src.y);
        ctx.drawImage(
          tileImages[t],
          rect.sx + 8, rect.sy + 8, rect.w, rect.h,
          x * TILE - camX, y * TILE - camY,
          TILE, TILE
        );
      }
      if(t===2||t===3){
          let up = (y-1 < 0 || isNeighborForTile(level[y-1]?.[x], t)) ? 1 : 0;
          let down = (y+1 >= MAP_H || isNeighborForTile(level[y+1]?.[x], t)) ? 1 : 0;
          let left = (x-1 < 0 || isNeighborForTile(level[y]?.[x-1], t)) ? 1 : 0;
          let right = (x+1 >= MAP_W || isNeighborForTile(level[y]?.[x+1], t)) ? 1 : 0;

          let mask = up * 1 + down * 2 + left * 4 + right * 8;
          
          const rawTileMap = {
              "10":{x:0,y:0},"14":{x:1,y:0},"6":{x:2,y:0},"2":{x:3,y:0},
              "11":{x:0,y:1},"15":{x:1,y:1},"7":{x:2,y:1},"3":{x:3,y:1},
              "9":{x:0,y:2}, "13":{x:1,y:2},"5":{x:2,y:2},"1":{x:3,y:2},
              "8":{x:0,y:3}, "12":{x:1,y:3},"4":{x:2,y:3},"0":{x:3,y:3},
          };
        const tileMap = {};
        for (const key in rawTileMap) {
          const ids = key.split('/').map(k => parseInt(k));
          for (const id of ids) tileMap[id] = rawTileMap[key];
        }

        // --- Autotile draw ---
        let src = tileMap[mask] || {x:3, y:3};
        let rect = getAutotileSrc(src.x, src.y);
        ctx.drawImage(
          tileImages[t],
          rect.sx + 8, rect.sy + 8, rect.w, rect.h,
          x * TILE - camX, y * TILE - camY,
          TILE, TILE
        );
      }
    }
  }


  // --- Finish ---
  if(finish && finishImg.complete){
      const cx = finish.x - camX;
      const cy = finish.y - camY;

      let brightness = 0.5;
      if(allCollected()){
          brightness = 0.9 + 0.1 * Math.sin(performance.now() * 0.005);
      }

      ctx.save();
      ctx.filter = `brightness(${brightness})`;
      ctx.drawImage(finishImg, cx, cy, finish.w, finish.h);
      ctx.restore();
  }


  function randRange(min, max) {
  return Math.random() * (max - min) + min;
  }
// --- Collectables ---
  collectables.forEach(c => {
    if (!c.collected) {

      c.timer += 1/60;
      if (c.timer >= c.frameSpeed) {
        c.timer -= c.frameSpeed;
        c.frame = (c.frame + 1) % c.frameCount;
      }

      const columns = 4;     
      const rows = 1;        
      const border = 8;      

      const frameWidth  = 128;
      const frameHeight = 128;

      const col = c.frame;  
      const row = 0;        

      const sx = border + col * frameWidth;
      const sy = border;

      const offsetX = randRange(-2, 2);
      const offsetY = randRange(-2, 2);

      ctx.drawImage(
        c.img,
        sx, sy, frameWidth, frameHeight,
        Math.round(c.x - camX + offsetX),
        Math.round(c.y - camY  + offsetY),
        frameWidth * (TILE / frameWidth),
        frameHeight * (TILE / frameWidth)
      );
    } else {
      if (!c.popTimer) {
        c.popTimer = 0;
        c.popDuration = 0.6; 
      }

      c.popTimer += 1/60; 

      const t = Math.min(c.popTimer / c.popDuration, 1);
      const maxRadius = 5000; 
      const radius = 1000/2 + t * maxRadius; 
      const alpha = 1 - t; 

      const cx = Math.round(c.x + c.w / 2 - camX);
      const cy = Math.round(c.y + c.h / 2 - camY);

      ctx.fillStyle = `rgba(128,0,128,${alpha})`; //color
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  });




  // --- Player draw ---
  const px = Math.round(player.x - camX);
  const py = Math.round(player.y - camY);
  const frameWidth = 128;
  const frameHeight = 192;
  const framePerRow = 8;
  const outerBorder = 8;

  let row = 0;
  if (player.vy < 0) {
    row = 2;
  } else if (player.vy > 0) {
    row = 3;
  } else if (Math.abs(player.vx) > 5) {
    row = 1;
  }

  if(player.vx < 0) {player.facing = -1};
  if(player.vx > 0) {player.facing = 1};


  player.timer = (player.timer || 0) + 1 / 60;
  const frameSpeed = (row === 1) ? 0.15 : 0.3;
  if (player.timer >= frameSpeed) {
    player.timer = 0;
    player.frame = ((player.frame || 0) + 1) % framePerRow;
  }
  const sx = outerBorder + (player.frame * frameWidth);
  const sy = outerBorder + (row * frameHeight);

  if (playerImg.complete) {
    const framePerRow = 8;
    const border = 8; 
    const frameWidth = (playerImg.width - border * 2) / framePerRow;
    const frameHeight = (playerImg.height - border * 2) / 4;

    const drawRow = row
    const col = player.frame % framePerRow;
    const sx = border + col * frameWidth;
    const sy = border + drawRow * frameHeight;

    const scale = TILE / frameWidth;
    const drawW = Math.round(frameWidth * scale);
    const drawH = Math.round(frameHeight * scale);

    const drawX = Math.round(px + player.w / 2 - drawW / 2);
    const drawY = Math.round(py + player.h - drawH + frameHeight * 0.1 * scale - 4); 

      ctx.imageSmoothingEnabled = false; 

      ctx.save();
      ctx.translate(drawX + drawW/2, drawY);     
      ctx.scale(player.facing, 1);              
      ctx.drawImage(
          playerImg,
          Math.floor(sx), Math.floor(sy), Math.floor(frameWidth), Math.floor(frameHeight),
          -drawW / 2, 0, drawW, drawH           
      );
      ctx.restore();

  } else {
    ctx.fillStyle = "#ffcc33";
    ctx.fillRect(Math.round(px), Math.round(py), player.w, player.h);
  }







  // --- HUD ---
  const remaining = collectables.filter(c=>!c.collected).length;
  ctx.fillStyle="white"; ctx.font="20px sans-serif";
  ctx.fillText(`Collectables remaining: ${remaining}`, 20, 30);

  if(levelFinished){
    ctx.fillStyle="red"; ctx.font="50px sans-serif";
    ctx.fillText("A simple proof of concept.", canvas.width/2-170, canvas.height/2);
  }
}


// --- Resize ---
function resizeCanvas(){
  const scale = (window.innerWidth/canvas.width)*CAMERA_SCALE;
  canvas.style.width=`${canvas.width*scale}px`;
  canvas.style.height=`${canvas.height*scale}px`;
}
window.addEventListener('resize',resizeCanvas);
resizeCanvas();

// --- Game Loop ---
let last=performance.now();
function loop(now){
  const dt = Math.min(0.033,(now-last)/1000);
  last = now;

  if(!levelFinished){
    let ax=0; if(keys.left) ax-=1; if(keys.right) ax+=1;
    const targetV=ax*player.speed; player.vx+=(targetV-player.vx)*Math.min(1,15*dt);

    if(keys.jump){
      if(player.onGround||player.coyoteTimer>0||player.jumpsLeft>0){
        if(player.vy>=0||player.onGround){
          player.vy=-player.jumpPower;
          player.onGround=false;
          player.coyoteTimer=0;
          if(player.jumpsLeft>0) player.jumpsLeft--;
        }
      }
    }
    player.vy+=GRAV*dt;if(player.vy>MAX_FALL) player.vy=MAX_FALL;
    if(!keys.left&&!keys.right) player.vx*=Math.pow(0.001,dt);

    resolveCollisions(dt);

    // Collectables
    collectables.forEach(c=>{
      if(!c.collected && player.x < c.x+c.w && player.x+player.w > c.x && player.y < c.y+c.h && player.y+player.h > c.y){
        c.collected = true;
      }
    });

    // Finish line
    if(finish && player.x+player.w>finish.x && player.x<finish.x+finish.w && player.y+player.h>finish.y && player.y<finish.y+finish.h){
      const remaining=collectables.filter(c=>!c.collected).length;
      if(remaining===0){levelFinished=true;player.vx=0;player.vy=0;keys.left=keys.right=keys.jump=false;}
    }
  }

  updateCamera(dt); render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
